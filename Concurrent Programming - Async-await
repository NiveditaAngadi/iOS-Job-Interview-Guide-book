https://github.com/swiftlang/swift-evolution/blob/main/proposals/0296-async-await.md#motivation-completion-handlers-are-suboptimal

https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency

1. Why async/await designed?
Modern Swift development involves a lot of asynchronous (or async) programming using closures and completion handlers, 
but these APIs are to use. 
This gets particularly problematic when many asynchronous operations are used, 
error handling is required, or control flow between asynchronous calls gets complicated. 
async and await is the language extension to make this a lot more natural and less error prone. 

Async/await - design introduces a coroutine model to Swift. 
Async functions allow asynchronous functions with concurrently-executing tasks and provides 
APIs for creating, querying, and cancelling tasks.

2. What is coroutine model? 
A coroutine is a computer program component that allows for the suspension and resumption of execution. 
Coroutines are lightweight threads that can be used to, 
1. simplify code that executes asynchronously. 
2. manage long-running tasks. 
3. implement cooperative tasks, exceptions, event loops, infinite lists, and pipes. 
4. perform an operation over time instead of instantly. 

Functions whose execution you can pause. 
Functions can opt into being async, allowing the programmer to compose complex logic involving 
asynchronous operations using the normal control-flow mechanisms. 
The compiler is responsible for translating an asynchronous function into an appropriate set of closures and state machines.

3. Define async/await.
Asynchronous functions - often known as async/await - allow asynchronous code to be written as if it were straight-line, synchrnous code.
The use of async/await naturally preserves the semantic structure of the code providing information necessary for atleast three cross-cutting 
improvements to the language. 
1. Better performance for asynchronous code. 
2. Better tooling to provide a more consistent experience while debugging, profiling, and exploring code. 
3. A foundation for future concurrency features like task priority and cancellation. 

4. What is the difference between Synchronous and Asynchronous functions?
Synchronous function can make a call, when it does, the function immediately waits for the call to complete.
Once the call completes, control returns to the function and picks up where it left off. 

Asynchronous function - it can make calls as usual, when it does it immediately waits for the call to complete. 
Once the call completes, control returns to the function and it picks up where it was. 

The only difference is that synchronous functions get to take full advantage of (part of) their thread and its stack, 
whereas asynchronous functions are able to completely give up that stack and use their own, separate storage. 

Because asynchronous functions must be able to abandon their thread, and synchronous functions don’t know how to abandon a thread, 
a synchronous function can’t ordinarily call an asynchronous function: 

In contrast, an asynchrnous function can call either synchronous or asynchrnous functions. 
While it’s calling a synchronous function, of course, it can’t give up its thread. 

In fact, asynchronous functions never just spontaneously give up their thread; 
they only give up their thread when they reach what’s called a suspension point. 
A suspension point can occur directly within a function, 
or it can occur within another asynchronous function that the function calls, 
but in either case the function and all of its asynchronous callers simultaneously abandon the thread.

5. What is suspension point?
A suspension point is a point in the execution of an asynchronous function where it has to give up its thread. 
Suspension points are always associated with some deterministic, syntatically explicit event in the function. They're never hidden
or asynchronous from the function's perspective.

It is important that suspension points are only associated with explicit operations.
In fact, it’s so important that this proposal requires that calls that might suspend be enclosed in an "await" expression.
These calls are referred to as potential suspension points, because it is not known statically whether they will actually suspend: 
that depends both on code not visible at the call site (e.g., the callee might depend on asynchronous I/O) 
as well as dynamic conditions (e.g., whether that asynchronous I/O will have to wait to complete).

The requirement for "await" on potential suspension points follows Swift's precedent of requiring "try" expressions to cover calls 
to functions that can throw errors.

6. How do you determine the async function?
By marking the function as "async" - indicating the function is asynchronous.

7. Which functions can not be asynchronous?
deinit 
storage accessors(i.e., the getters and setters for properties and subscripts) cannot be async. 

8. Define the function types?
struct FunctionTypes {
  var syncNonThrowing: () -> Void 
  var syncThrowing: () throws -> Void 
  var asyncNonThrowing: () async -> Void 
  var asynThrowing: () async throws -> Void 

 mutating func demonstrateConversions() {
    // Okay to add 'async' and/or 'throws'    
    asyncNonThrowing = syncNonThrowing
    asyncThrowing = syncThrowing
    syncThrowing = syncNonThrowing
    asyncThrowing = asyncNonThrowing
    
    // Error to remove 'async' or 'throws'
    syncNonThrowing = asyncNonThrowing // error
    syncThrowing = asyncThrowing       // error
    syncNonThrowing = syncThrowing     // error
    asyncNonThrowing = syncThrowing    // error
  }
}

9. What is await expression? 
A call to value of async function type(including a direct call to an async function) introduces a potential suspension point. 
Any potential suspension point must occur within an asynchronous context( async function). 
Furthermore, it must occur  within operand of an await expression. 

// func redirectURL(for url: URL) async -> URL { ... }
// func dataTask(with: URL) async throws -> (Data, URLResponse) { ... }

let newURL = await server.redirectURL(for: url)
let (data, response) = try await session.dataTask(with: newURL)

10. Where suspension point not occur?
1. A potential suspension point must not occur within autoclosure that is not of async function. 
2. A potential suspension point must not occur within defer block. 

11.
